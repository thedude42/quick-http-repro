"use strict";

var test = require("tape"),
    fs = require("fs"),
    path = require("path"),
    crypto = require("crypto"),
    exec = require("child_process").exec,
    reload = require('require-reload')(require),
    libqhr = require("../lib/libqhr"),
    defaultConfig = { flowDir:null,
                portnum:null,
                tcpflowReadopt:"",
                pcap:null
    };

function endTest(t, dir) {
    var files;
    if (dir) {
        files = fs.readdirSync(dir);
        files.forEach(function(file) {
            fs.unlinkSync(path.resolve(dir,file));
        });
        fs.rmdirSync(dir);
    }
    t.end();
}

test("validate test-data: http.pcap", function(t) {
    var httpsha = crypto.createHash("sha1");
    t.plan(1);
    fs.createReadStream("test-data/http.pcap")
    .on("data", function(chunk) {
        httpsha.update(chunk);
    })
    .on("end", function() {
        t.equals(httpsha.digest('hex'), "87d6f10180e7a7c5e9125c570d6ba6216de0fb6f");
        t.end();
    })
});

test("validate test-data: wireshark.raw", function(t) {
    var wiresharksha = crypto.createHash("sha1");
    t.plan(1);
    fs.createReadStream("test-data/wireshark.raw")
    .on("data", function(chunk) {
        wiresharksha.update(chunk);
    })
    .on("end", function() {
        t.equals(wiresharksha.digest('hex'), "a1d5e2129834b96842a8501bacecf348e092dbd4");
        t.end();
    })
});

test("\nargv test: -d, --complete and --tcp-port", function(t) {
    //reloadLibQHR();
    t.deepEquals(defaultConfig, libqhr.getArgsConfig());
    var testdir = "testdir";
    fs.mkdirSync(testdir);
    var args =  libqhr.processArgs(["argv[0]", "argv[1]", "-d", testdir, "--complete", "--tcp-port", "8100"]);
    t.equals(args.flowdir, testdir);
    t.equals(libqhr.getArgsConfig().flowDir, testdir);
    t.ok(args.complete);
    t.equals(args.tcpPort, "8100");
    endTest(t, testdir);
})

test("\nargv test: with -p only", function(t) {
    reloadLibQHR();
    t.deepEquals(defaultConfig, libqhr.getArgsConfig());
    console.log("Calling processArgs()");
    var args = libqhr.processArgs(["argv[0]", "argv[1]", "-p", "test.pcap"]);
    t.equal(args.pcap, "test.pcap");
    t.equal(libqhr.getArgsConfig().pcap, "test.pcap", "-p options works");
    t.equal(libqhr.getArgsConfig().flowDir, "flows", "default flowdir works with just -p options");
    t.notOk(args.complete, "the --complete option correctly was not set");
    endTest(t);
});

test("\nargv test: -d and -p", function(t) {
    reloadLibQHR();
    t.deepEquals(defaultConfig, libqhr.getArgsConfig());
    var testdir = "testdir";
    fs.mkdirSync(testdir);
    var args = libqhr.processArgs(["argv[0]", "argv[1]", "-d", testdir, "-p", "test.pcap"]);
    t.equal(args.pcap, "test.pcap");
    t.equal(libqhr.getArgsConfig().pcap, "test.pcap");
    t.equals(args.flowdir, testdir);
    t.equals(libqhr.getArgsConfig().flowDir, testdir);
    t.notOk(args.complete);
    endTest(t, testdir);
});

test("\ntest doTcpflow, http.pcap", function(t) {
    reloadLibQHR();
    t.deepEquals(defaultConfig, libqhr.getArgsConfig());
    var testdir = "tcpflowTestDir";
    fs.mkdirSync(testdir);
    var args = libqhr.processArgs(["argv[0]", "argv[1]", "-d", testdir, "-p", "test-data/http.pcap"]);
    libqhr.doTcpFlow(function(err, result) {
        t.equals(err, null);
        t.equals(result, testdir);
        t.equals(libqhr.getArgsConfig().pcap, "test-data/http.pcap");
        t.equals(fs.readdirSync(testdir).length, 17);
        endTest(t, testdir);
    })
});

test("\nparse a file: 096.126.115.201.00080-024.019.225.228.13836", function(t) {
    t.plan(5);
    reloadLibQHR();
    t.deepEquals(defaultConfig, libqhr.getArgsConfig());
    var testdir = "parseTestDir";
    fs.mkdirSync(testdir);
    libqhr.processArgs(["argv[0]", "argv[1]", "-d", testdir, "-p", "test-data/http.pcap"]);
    libqhr.doTcpFlow(function(err) {
        var files =[testdir+"/096.126.115.201.00080-024.019.225.228.13836"];
        libqhr.getParsedFiles(files, function(err, fileDictObj) {
            t.notOk(err, "parser callback did not indicate an error");
            t.equals(fileDictObj.files.length, 1, "The correct number of files are recorded");
            t.notOk(fileDictObj.parsed[testdir+"/096.126.115.201.00080-024.019.225.228.13836"]
            .isWireshark, "tcpflow file is not seen as generated by wireshark");
            t.equals(fileDictObj
                .parsed[testdir+"/096.126.115.201.00080-024.019.225.228.13836"].parsedMessages.length, 9, "correct number of parsed HTTP messages");
            endTest(t, testdir);
        });
    });
});

test("\nparse a file: wireshark.raw", function(t) {
    t.plan(5);
    reloadLibQHR();
    t.deepEquals(defaultConfig, libqhr.getArgsConfig());
    var testdir = "parseTestDir";
    fs.mkdirSync(testdir);
    libqhr.processArgs(["argv[0]", "argv[1]", "-d", testdir]);
    libqhr.doTcpFlow(function(err) {
        var files =["test-data/wireshark.raw"];
        libqhr.getParsedFiles(files, function(err, fileDictObj) {
            t.notOk(err, "parser did not pass error for parsing wireshark.raw");
            t.equals(fileDictObj.files.length, 1, "correct number of files in return object");
            t.ok(fileDictObj.parsed["test-data/wireshark.raw"].isWireshark, "Correctly identified wireshark flow")
            t.equals(fileDictObj.parsed["test-data/wireshark.raw"].parsedMessages.length, 22, "correct number of parsed HTTP messages");
            endTest(t, testdir);
        });
    });
});

function reloadLibQHR() {
    console.log("reloading libqhr")
    libqhr = reload("../lib/libqhr");
    libqhr._reloadCommander();
}
